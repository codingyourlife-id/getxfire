// part of '../getxfire.dart';

// /// Constants
// const String linkPhoneAuth = 'link';
// const String signInPhoneAuth = 'signIn';
// const String createdAt = 'createdAt';
// const String updatedAt = 'updatedAt';

// enum RenderType {
//   postCreate,
//   postUpdate,
//   postDelete,
//   commentCreate,
//   commentUpdate,
//   commentDelete,
//   fileUpload,
//   fileDelete,
//   fetching,
//   finishFetching,
// }

// enum ForumStatus {
//   noPosts,
//   noMorePosts,
// }

// /// Error codes.
// ///
// /// All error codes generated by GetxFire is upper cased.
// const String LOGIN_FIRST = 'LOGIN_FIRST';
// const String CATEGORY_EMPTY = 'CATEGORY_EMPTY';
// const String CATEGORY_NOT_EXISTS = 'CATEGORY_NOT_EXISTS';
// const String ALGOLIA_INDEX_NAME_IS_EMPTY = 'ALGOLIA_INDEX_NAME_IS_EMPTY';
// const String UPLOAD_CANCELLED = 'UPLOAD_CANCELLED';
// const String EMPTY_PUSH_TARGET = 'EMPTY_PUSH_TARGET';
// const String EMPTY_FIREBASE_SERVER_TOKEN = 'EMPTY_FIREBASE_SERVER_TOKEN';
// const String PUSH_NOTIFICATION_NOT_ENABLED = 'PUSH_NOTIFICATION_NOT_ENABLED';

// // const String FAILED_ENTER_CHAT_ROOM = 'FAILED_ENTER_CHAT_ROOM';

// /// Algolia codes
// const String ALGOLIA_APP_ID = 'ALGOLIA_APP_ID';
// const String ALGOLIA_ADMIN_API_KEY = 'ALGOLIA_ADMIN_API_KEY';
// const String ALGOLIA_INDEX_NAME = 'ALGOLIA_INDEX_NAME';

// class NotificationOptions {
//   static String notifyCommentsUnderMyPost = 'notifyPost';
//   static String notifyCommentsUnderMyComment = 'notifyComment';

//   /// "notifyPost_" + category
//   static String post(String category) {
//     return notifyCommentsUnderMyPost + '_' + category;
//   }

//   static String comment(String category) {
//     return notifyCommentsUnderMyComment + '_' + category;
//   }
// }

// /// For short
// final String notifyPost = NotificationOptions.notifyCommentsUnderMyPost;
// final String notifyComment = NotificationOptions.notifyCommentsUnderMyComment;

// typedef Render = void Function(RenderType x);
// const ERROR_SIGNIN_ABORTED = 'ERROR_SIGNIN_ABORTED';

// /// [UserChangeType.public] is for `/meta/user/public/{uid}` change(read for the first time and listening for update)
// /// [UserChangeType.document] is for `/users/{uid}` change.
// /// [UserChangeType.auth] is for login, or logout. Be reminded that login even will be fired twice. This is the nature of firebase.
// /// [UserChangeType.profile] is for changing `photoURL` or `displayName`.
// // enum UserChangeType { auth, document, public, register, profile }

// /// Event data on [userChange] event
// // class UserChangeData {
// //   UserChangeData(this.type, {this.user});
// //   UserChangeType type;
// //   User user;
// // }

// enum NotificationType { onMessage, onLaunch, onResume }

// typedef NotificationHandler = void Function(Map<String, dynamic> messge,
//     Map<String, dynamic> data, NotificationType type);

// typedef SocialLoginErrorHandler = void Function(String error);
// typedef SocialLoginSuccessHandler = void Function(User user);

// class ForumData {
//   /// [render] will be called when the view need to be re-rendered.
//   ForumData({
//     required this.category,
//     required this.render,
//     this.uid,
//     this.noOfPostsPerFetch = 12,
//   });

//   /// This is for infinite scrolling in forum screen.
//   late RenderType _inLoading;
//   bool get inLoading => _inLoading == RenderType.fetching;

//   /// Tell the app to update(re-render) the screen.
//   ///
//   /// This method should be invoked whenever forum data changes like fetching
//   /// more posts, comment updating, voting, etc.
//   updateScreen(RenderType? x) {
//     _inLoading = x!;
//     if (render != null) render(x);
//     // render(x);
//   }

//   late ForumStatus status;
//   bool get shouldFetch => inLoading == false && status == null;
//   bool get shouldNotFetch => !shouldFetch;

//   late String category;

//   /// The app can show(search) posts of a user.
//   ///
//   /// [uid] could be the login user's uid or other user's uid.
//   String? uid;

//   /// [fetched] becomes true if the app had fetched the first batch of posts
//   /// from Firestore. Mostly the UI shows a spinner(loader) that the fetching
//   /// is in progress. And if there is no document to fetch, it would never
//   /// become true that causes the UI show spinner and wait forever.
//   ///
//   /// There might no posts there even after it has fetched. So, [fetched] might
//   /// be true while [posts] is still empty array.
//   ///
//   late bool fetched = false;

//   /// No of posts per each fetch. This can be overwritten by Firestore settings.
//   late int noOfPostsPerFetch;
//   late List<Map<String, dynamic>> posts = [];
//   late Render render;

//   late StreamSubscription postQuerySubscription;
//   late Map<String, StreamSubscription> commentsSubcriptions = {};

//   /// This must be called on Forum screen widget `dispose` to cancel the subscriptions.
//   leave() {
//     postQuerySubscription.cancel();

//     // TODO: unsubscribe all comments list stream subscriptions.
//     if (commentsSubcriptions.isNotEmpty) {
//       commentsSubcriptions.forEach((key, value) {
//         value.cancel();
//       });
//     }
//   }
// }
